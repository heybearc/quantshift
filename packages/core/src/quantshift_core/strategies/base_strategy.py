"""
Base Strategy Class - Broker-Agnostic Trading Strategy Framework

This module provides the abstract base class for all trading strategies.
Strategies are completely broker-agnostic and contain only pure trading logic.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum
from typing import Dict, List, Optional, Any
from datetime import datetime
import pandas as pd
import structlog

logger = structlog.get_logger()


class SignalType(Enum):
    """Trading signal types."""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"


@dataclass
class Signal:
    """
    Trading signal generated by a strategy.
    
    Completely broker-agnostic - contains only the trading decision,
    not how to execute it.
    """
    signal_type: SignalType
    symbol: str
    timestamp: datetime
    price: float
    confidence: float = 1.0  # 0.0 to 1.0
    reason: str = ""
    metadata: Dict[str, Any] = None
    
    # Risk management parameters (calculated by strategy)
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    position_size: Optional[int] = None
    
    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}


@dataclass
class Account:
    """
    Broker-agnostic account information.
    
    Normalized account data that any broker can provide.
    """
    equity: float
    cash: float
    buying_power: float
    portfolio_value: float
    positions_count: int = 0
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            'equity': self.equity,
            'cash': self.cash,
            'buying_power': self.buying_power,
            'portfolio_value': self.portfolio_value,
            'positions_count': self.positions_count
        }


@dataclass
class Position:
    """
    Broker-agnostic position information.
    """
    symbol: str
    quantity: float
    entry_price: float
    current_price: float
    market_value: float
    unrealized_pl: float
    unrealized_plpc: float
    side: str  # 'long' or 'short'
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            'symbol': self.symbol,
            'quantity': self.quantity,
            'entry_price': self.entry_price,
            'current_price': self.current_price,
            'market_value': self.market_value,
            'unrealized_pl': self.unrealized_pl,
            'unrealized_plpc': self.unrealized_plpc,
            'side': self.side
        }


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.
    
    Strategies are completely broker-agnostic and contain only pure trading logic.
    They receive market data and account information, and return trading signals.
    
    The actual execution of trades is handled by broker-specific executors.
    """
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """
        Initialize strategy with configuration.
        
        Args:
            config: Strategy configuration parameters
        """
        self.config = config or {}
        self.name = self.__class__.__name__
        self.logger = logger.bind(strategy=self.name)
        
    @abstractmethod
    def generate_signals(
        self,
        market_data: pd.DataFrame,
        account: Account,
        positions: List[Position]
    ) -> List[Signal]:
        """
        Generate trading signals based on market data and account state.
        
        This is the core strategy logic - completely broker-agnostic.
        
        Args:
            market_data: Historical market data (OHLCV)
            account: Current account information
            positions: Current open positions
            
        Returns:
            List of trading signals (BUY/SELL/HOLD)
        """
        pass
    
    @abstractmethod
    def calculate_position_size(
        self,
        signal: Signal,
        account: Account,
        atr: Optional[float] = None
    ) -> int:
        """
        Calculate position size based on risk management rules.
        
        Args:
            signal: Trading signal
            account: Current account information
            atr: Average True Range (volatility measure)
            
        Returns:
            Number of shares/units to trade
        """
        pass
    
    def calculate_stop_loss(
        self,
        signal: Signal,
        atr: Optional[float] = None
    ) -> Optional[float]:
        """
        Calculate stop loss price for a signal.
        
        Args:
            signal: Trading signal
            atr: Average True Range (volatility measure)
            
        Returns:
            Stop loss price, or None if no stop loss
        """
        if atr is None:
            return None
            
        # Default: 2x ATR stop loss
        atr_multiplier = self.config.get('atr_multiplier', 2.0)
        
        if signal.signal_type == SignalType.BUY:
            return signal.price - (atr * atr_multiplier)
        elif signal.signal_type == SignalType.SELL:
            return signal.price + (atr * atr_multiplier)
        
        return None
    
    def calculate_take_profit(
        self,
        signal: Signal,
        stop_loss: Optional[float] = None
    ) -> Optional[float]:
        """
        Calculate take profit price for a signal.
        
        Args:
            signal: Trading signal
            stop_loss: Stop loss price
            
        Returns:
            Take profit price, or None if no take profit
        """
        if stop_loss is None:
            return None
            
        # Default: 2:1 reward-to-risk ratio
        risk_reward_ratio = self.config.get('risk_reward_ratio', 2.0)
        risk = abs(signal.price - stop_loss)
        
        if signal.signal_type == SignalType.BUY:
            return signal.price + (risk * risk_reward_ratio)
        elif signal.signal_type == SignalType.SELL:
            return signal.price - (risk * risk_reward_ratio)
        
        return None
    
    def validate_signal(
        self,
        signal: Signal,
        account: Account,
        positions: List[Position]
    ) -> bool:
        """
        Validate a signal against risk management rules.
        
        Args:
            signal: Trading signal to validate
            account: Current account information
            positions: Current open positions
            
        Returns:
            True if signal is valid, False otherwise
        """
        # Check if we have enough buying power
        if signal.signal_type == SignalType.BUY:
            estimated_cost = signal.price * (signal.position_size or 1)
            if estimated_cost > account.buying_power:
                self.logger.warning(
                    "insufficient_buying_power",
                    signal=signal.symbol,
                    cost=estimated_cost,
                    buying_power=account.buying_power
                )
                return False
        
        # Check maximum positions limit
        max_positions = self.config.get('max_positions', 5)
        if signal.signal_type == SignalType.BUY and len(positions) >= max_positions:
            self.logger.warning(
                "max_positions_reached",
                current=len(positions),
                max=max_positions
            )
            return False
        
        # Check if we already have a position in this symbol
        if signal.signal_type == SignalType.BUY:
            for pos in positions:
                if pos.symbol == signal.symbol:
                    self.logger.info(
                        "position_already_exists",
                        symbol=signal.symbol
                    )
                    return False
        
        return True
    
    def get_config(self, key: str, default: Any = None) -> Any:
        """Get configuration value."""
        return self.config.get(key, default)
    
    def update_config(self, config: Dict[str, Any]) -> None:
        """Update strategy configuration."""
        self.config.update(config)
        self.logger.info("config_updated", config=config)
